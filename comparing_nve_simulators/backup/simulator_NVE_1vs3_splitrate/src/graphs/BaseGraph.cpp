/*
 * BaseGraph.cpp
 *
 *  Created on: Oct 16, 2016
 *      Author: abean
 */

#include "../graphs/BaseGraph.h"

BaseGraph::BaseGraph() {

	clear();
	this->directedFlag = 0;
	this->linksAmount = 0;
	this->nodesAmount = 0;
}

BaseGraph::BaseGraph(const string fileName) {

	clear();
	this->directedFlag = 0;
	this->linksAmount = 0;
	this->nodesAmount = 0;
	cout << "   INFO: Construct Network Start " << fileName << endl;
	constructGraphFromGraphFile(fileName);
	cout << "   INFO: Construct Network End " << endl;
}

BaseGraph::~BaseGraph() {
	// TODO Auto-generated destructor stub
	this->directedFlag = 0;
	this->linksAmount = 0;
	this->nodesAmount = 0;
	clear();
}

void BaseGraph::clear() {
}

/*
 * linkId format : from_to
 */
string BaseGraph::makeLinkId(const string from, const string to) const {
	string str;
	str = from + '_' + to;
	return str;
}

/*
 *  add adjacency node into adjacency node map for a node
 */
void BaseGraph::addAdjacencyNodes(const string from, const string to) {
	map<string, vector<string> >::iterator it = this->adjacencyNodes.find(from);
	vector<string> adjacencyNodes;
	if (it == this->adjacencyNodes.end()) {
		adjacencyNodes.push_back(to);
		it = this->adjacencyNodes.begin();
		this->adjacencyNodes.insert(it,
				pair<string, vector<string> >(from, adjacencyNodes));
	} else {
		adjacencyNodes = it->second;
		if (find(adjacencyNodes.begin(), adjacencyNodes.end(), to)
				== adjacencyNodes.end()) {
			adjacencyNodes.push_back(to);
			it->second = adjacencyNodes;
		}
	}
}

/*
 * add two (from , to ) nodes connected by link for graph
 */
void BaseGraph::addNodeToGraph(const string nodeId) {
	if (this->Nodes.count(nodeId) == 0) {
		// save node ID and pointer into index map
		map<string, BaseNode*>::iterator it = this->Nodes.begin();
		BaseNode * Node = new BaseNode(nodeId);
		this->Nodes.insert(it, pair<string, BaseNode*>(nodeId, Node));
		// save node pointer into vector
		if (find(this->NodePtrs.begin(), this->NodePtrs.end(), Node)
				== this->NodePtrs.end()) {
			this->NodePtrs.push_back(Node);
		}
	}
}

const map<string, vector<string> >& BaseGraph::getAdjacencyNodes() const {
	return adjacencyNodes;
}

void BaseGraph::setAdjacencyNodes(
		const map<string, vector<string> >& adjacencyNodes) {
	this->adjacencyNodes = adjacencyNodes;
}

int BaseGraph::getDirectedFlag() const {
	return directedFlag;
}

void BaseGraph::setDirectedFlag(int directedFlag) {
	this->directedFlag = directedFlag;
}

const vector<BaseLink*>& BaseGraph::getLinkPtrs() const {
	return LinkPtrs;
}

void BaseGraph::setLinkPtrs(const vector<BaseLink*>& linkPtrs) {
	LinkPtrs = linkPtrs;
}

const map<string, BaseLink*>& BaseGraph::getLinks() const {
	return Links;
}

const BaseLink* BaseGraph::getLink(const string linkId) const {
	map<string, BaseLink*>::const_iterator lIter = this->Links.find(linkId);
	if (lIter != this->Links.end()) {
		return lIter->second;
	} else {
		return NULL;
	}
}

void BaseGraph::setLinks(const map<string, BaseLink*>& links) {
	Links = links;
}

int BaseGraph::getLinksAmount() const {
	return linksAmount;
}

void BaseGraph::setLinksAmount(int linksAmount) {
	this->linksAmount = linksAmount;
}

const vector<BaseNode*>& BaseGraph::getNodePtrs() const {
	return NodePtrs;
}

void BaseGraph::setNodePtrs(const vector<BaseNode*>& nodePtrs) {
	NodePtrs = nodePtrs;
}

const map<string, BaseNode*>& BaseGraph::getNodes() const {
	return Nodes;
}

void BaseGraph::setNodes(const map<string, BaseNode*>& nodes) {
	Nodes = nodes;
}

int BaseGraph::getNodesAmount() const {
	return nodesAmount;
}

void BaseGraph::setNodesAmount(int nodesAmount) {
	this->nodesAmount = nodesAmount;
}

/*
 * add link for grpah
 */
void BaseGraph::addLinkToGraph(const string linkId, const string from,
		const string to, const double cost, const double delay,
		const double bandwidth, const string fromDomain,
		const string toDomain) {
	if (this->Links.count(linkId) == 0) {
		// save each link id and pointer into index map
		map<string, BaseLink*>::iterator it = this->Links.begin(); // max efficiency inserting
		BaseLink * blink = new BaseLink(from, to, cost, delay, bandwidth,
				fromDomain, toDomain);
		this->Links.insert(it, pair<string, BaseLink*>(linkId, blink));
		// save each link pointer into vector
		if (find(this->LinkPtrs.begin(), this->LinkPtrs.end(), blink)
				== this->LinkPtrs.end()) {
			this->LinkPtrs.push_back(blink);
		}
	}
}

/*
 * construct a Graph from graph file generated by
 * brite network topology generator
 */
void BaseGraph::constructGraphFromGraphFile(const string filename) {

	ifstream ifs(filename.c_str(), ifstream::in);

	if (!ifs) {
		cout << "Error.Can't open input data file." << endl;
		exit(1);
	}

	string line, nodes("Nodes:"), edges("Edges:");
	string edgeId, from, to, fromDomain, toDomain;
	double length = 0.0; // distance between two adjacency nodes generated by brite, equals to link 'cost'
	double delay = 0.0, bandwidth = 0.0;

	// real file by loop unit the line includes "Edges:"
	while (getline(ifs, line) && (line.find(edges) == string::npos)) {
	}

	/*
	 * the next sections is about graph constructor from graph file generated by brite
	 * network topology generator.
	 * First,   add each link information
	 * Second,  add each node information
	 * Third,   set the node and link amount of graph
	 * Third,   get the adjacency node information of each node
	 *          according to each link information
	 */
	// next line is detailed link information for graph
	while (getline(ifs, line) && line.size() != 0) {

		// get a detailed item information
		istringstream is(line);
		is >> edgeId >> from >> to >> bandwidth >> delay >> length >> fromDomain
				>> toDomain;

		// get link ID in format 'from_to'
		string fromLinkId = makeLinkId(from, to);
		string toLinkId = makeLinkId(to, from);

		double cost = length;
		// add link for graph
		addLinkToGraph(fromLinkId, from, to, cost, delay, bandwidth, fromDomain,
				toDomain);
		addLinkToGraph(toLinkId, to, from, cost, delay, bandwidth, toDomain,
				fromDomain);
		// add from node
		addNodeToGraph(from);
		// add to node
		addNodeToGraph(to);
		// add adjacency nodes for each node
		addAdjacencyNodes(from, to);
		addAdjacencyNodes(to, from);
	}
	ifs.close();  // close the graph file

	//set graph basic information
	this->linksAmount = this->Links.size();
	this->nodesAmount = this->Nodes.size();

//	printMap(this->Links);
//	//printMap(this->Nodes);
//	printMapVector(this->adjacencyNodes);
//	printLinkDetails(this->Links);

}

/*
 * print vector<T> details
 */
template<class T>
void BaseGraph::printVector(const vector<T> vtr) {
	cout << " printed vector's size: " << vtr.size() << endl;
	for (typename vector<T>::const_iterator it = vtr.begin(); it != vtr.end();
			++it) {
		cout << *it << " ";
	}
	cout << endl;
}

/*
 * print map< T1, T2 > details
 */
template<class T1, class T2>
void BaseGraph::printMap(const map<T1, T2> vtr) {
	cout << " printed map's size: " << vtr.size() << endl;
	for (typename map<T1, T2>::const_iterator it = vtr.begin(); it != vtr.end();
			++it) {
		cout << it->first << " : " << it->second << endl;
	}
	cout << endl;
}

/*
 * print map< T1, vector<T2> > details
 */
template<class T1, class T2>
void BaseGraph::printMapVector(const map<T1, vector<T2> > vtr) {
	cout << " printed map< string, vector>'s size: " << vtr.size() << endl;
	for (typename map<T1, vector<T2> >::const_iterator it = vtr.begin();
			it != vtr.end(); ++it) {
		cout << it->first << " : ";
		printVector(it->second);
		cout << endl;
	}
	cout << endl;
}

/*
 * print link details
 */
template<class T1>
void BaseGraph::printLinkDetails(const map<T1, BaseLink*> vtr) {
	cout << " The amount of links :" << vtr.size() << endl;
	for (typename map<T1, BaseLink*>::const_iterator it = vtr.begin();
			it != vtr.end(); ++it) {
		cout << it->first << " : ";
		cout << it->second->getFrom() << " " << it->second->getTo() << " "
				<< it->second->getWeight() << " " << it->second->getDelay()
				<< " " << it->second->getBandwidth() << " "
				<< it->second->getFromDomain() << " "
				<< it->second->getToDomain();
		cout << endl;
	}
	cout << endl;
}
